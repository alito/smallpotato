/*****
  command line parser -- generated by clig
  (http://wsd.iitb.fhg.de/~kir/clighome/)

  The command line parser `clig':
  (C) 1995---2001 Harald Kirsch (kirschh@lionbioscience.com)
*****/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <float.h>
#include <math.h>

#include "cmdline.h"

char *Program;

/*@-null*/

static Cmdline cmd = {
  /***** -help: show usage information */
  /* show_helpP = */ 0,
  /***** -V: show program version */
  /* show_versionP = */ 0,
  /***** -random: play random moves */
  /* randomP = */ 0,
  /***** -complete: play full negamax */
  /* completeP = */ 0,
  /***** -onestep: play with depth of one */
  /* onestepP = */ 0,
  /***** -multistep: play with fixed depth alpha-beta cutoff algorithm */
  /* multistepP = */ 0,
  /***** -negascout: play with iterative deepening negascout algorithm (default) */
  /* negascoutP = */ 0,
  /***** -fixed: evaluate board by fixed piece values */
  /* fixedevalP = */ 0,
  /***** -relative: evaluate board by relative proportion to opponent */
  /* relativeevalP = */ 0,
  /***** -record: record game */
  /* recordP = */ 0,
  /***** -position: evaluate board by piece values relative to position */
  /* positionevalP = */ 0,
  /***** -nobook: do not use opening book */
  /* nobookP = */ 0,
  /***** -noresign: never resign */
  /* noresignP = */ 0,
  /***** -norecord: do not record the game */
  /* norecordP = */ 0,
  /***** -log: file where to write all spurious output messages */
  /* logfileP = */ 0,
  /* logfile = */ (char*)0,
  /* logfileC = */ 0,
  /***** -gamefile: file where to record the games */
  /* gamefileP = */ 0,
  /* gamefile = */ (char*)0,
  /* gamefileC = */ 0,
  /***** -values: file specifying pieces values */
  /* valuefileP = */ 0,
  /* valuefile = */ (char*)0,
  /* valuefileC = */ 0,
  /***** -config: configuration file - default is sp.rc, or sp.ini  */
  /* configfileP = */ 0,
  /* configfile = */ (char*)0,
  /* configfileC = */ 0,
  /***** -compname: name to report for the engine  */
  /* computernameP = */ 0,
  /* computername = */ (char*)0,
  /* computernameC = */ 0,
  /***** -book: opening book file */
  /* bookfileP = */ 0,
  /* bookfile = */ (char*)0,
  /* bookfileC = */ 0,
  /***** -guiveup: Pawn values deficit at which to resign (default is 6.5, will be ignored if combined with -relative)  */
  /* resignP = */ 0,
  /* resign = */ (float)0,
  /* resignC = */ 0,
  /***** -d: maximum depth of search */
  /* dP = */ 0,
  /* d = */ (int)0,
  /* dC = */ 0,
  /***** -r: randomness introduced into the evaluation algorithm as a percentage of a pawn's value */
  /* randomvarianceP = */ 0,
  /* randomvariance = */ (int)0,
  /* randomvarianceC = */ 0,
  /***** -hs: number of entries in hash table (will be deprecated) */
  /* hashsizeP = */ 0,
  /* hashsize = */ (int)0,
  /* hashsizeC = */ 0,
  /***** -hk: hash table size in kilobytes */
  /* hashkilobytesP = */ 0,
  /* hashkilobytes = */ (int)0,
  /* hashkilobytesC = */ 0,
  /***** -mindepth: minimum depth at which an epd can be considered solved */
  /* epdmindepthP = */ 0,
  /* epdmindepth = */ (int)0,
  /* epdmindepthC = */ 0,
  /***** -draw: value, in hundredth of a pawn, of a draw */
  /* drawvalueP = */ 0,
  /* drawvalue = */ (int)0,
  /* drawvalueC = */ 0,
  /***** -v: verbosity level */
  /* verboseP = */ 0,
  /* verbose = */ (int)0,
  /* verboseC = */ 0,
  /***** uninterpreted rest of command line */
  /* argc = */ 0,
  /* argv = */ (char**)0,
  /***** the original command line concatenated */
  /* tool = */ NULL
};

/*@=null*/

/***** let LCLint run more smoothly */
/*@-predboolothers*/
/*@-boolops*/


/******************************************************************/
/*****
 This is a bit tricky. We want to make a difference between overflow
 and underflow and we want to allow v==Inf or v==-Inf but not
 v>FLT_MAX. 

 We don't use fabs to avoid linkage with -lm.
*****/
static void
checkFloatConversion(double v, char *option, char *arg)
{
  char *err = NULL;

  if( (errno==ERANGE && v!=0.0) /* even double overflowed */
      || (v<HUGE_VAL && v>-HUGE_VAL && (v<0.0?-v:v)>(double)FLT_MAX) ) {
    err = "large";
  } else if( (errno==ERANGE && v==0.0) 
	     || (v!=0.0 && (v<0.0?-v:v)<(double)FLT_MIN) ) {
    err = "small";
  }
  if( err ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of option `%s' to %s to represent\n",
	    Program, arg, option, err);
    exit(EXIT_FAILURE);
  }
}

int
getIntOpt(int argc, char **argv, int i, int *value, int force)
{
  char *end;
  long v;

  if( ++i>=argc ) goto nothingFound;

  errno = 0;
  v = strtol(argv[i], &end, 0);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace((int) *end) ) end+=1;
  if( *end ) goto nothingFound;

  /***** check if it fits into an int */
  if( errno==ERANGE || v>(long)INT_MAX || v<(long)INT_MIN ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of option `%s' to large to represent\n",
	    Program, argv[i], argv[i-1]);
    exit(EXIT_FAILURE);
  }
  *value = (int)v;

  return i;

nothingFound:
  if( !force ) return i-1;

  fprintf(stderr, 
	  "%s: missing or malformed integer value after option `%s'\n",
	  Program, argv[i-1]);
    exit(EXIT_FAILURE);
}
/**********************************************************************/

int
getIntOpts(int argc, char **argv, int i, 
	   int **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;
  long v;
  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
  alloced = cmin + 4;
  *values = (int*)calloc((size_t)alloced, sizeof(int));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = (int *) realloc(*values, alloced*sizeof(int));
      if( !*values ) goto outMem;
    }

    errno = 0;
    v = strtol(argv[used+i+1], &end, 0);

    /***** check for conversion error */
    if( end==argv[used+i+1] ) break;

    /***** check for surplus non-whitespace */
    while( isspace((int) *end) ) end+=1;
    if( *end ) break;

    /***** check for overflow */
    if( errno==ERANGE || v>(long)INT_MAX || v<(long)INT_MIN ) {
      fprintf(stderr, 
	      "%s: parameter `%s' of option `%s' to large to represent\n",
	      Program, argv[i+used+1], argv[i]);
      exit(EXIT_FAILURE);
    }

    (*values)[used] = (int)v;

  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be an "
	    "integer value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/

int
getLongOpt(int argc, char **argv, int i, long *value, int force)
{
  char *end;

  if( ++i>=argc ) goto nothingFound;

  errno = 0;
  *value = strtol(argv[i], &end, 0);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace((int) *end) ) end+=1;
  if( *end ) goto nothingFound;

  /***** check for overflow */
  if( errno==ERANGE ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of option `%s' to large to represent\n",
	    Program, argv[i], argv[i-1]);
    exit(EXIT_FAILURE);
  }
  return i;

nothingFound:
  /***** !force means: this parameter may be missing.*/
  if( !force ) return i-1;

  fprintf(stderr, 
	  "%s: missing or malformed value after option `%s'\n",
	  Program, argv[i-1]);
    exit(EXIT_FAILURE);
}
/**********************************************************************/

int
getLongOpts(int argc, char **argv, int i, 
	    long **values,
	    int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
  alloced = cmin + 4;
  *values = calloc((size_t)alloced, sizeof(long));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = realloc(*values, alloced*sizeof(long));
      if( !*values ) goto outMem;
    }

    errno = 0;
    (*values)[used] = strtol(argv[used+i+1], &end, 0);

    /***** check for conversion error */
    if( end==argv[used+i+1] ) break;

    /***** check for surplus non-whitespace */
    while( isspace((int) *end) ) end+=1; 
    if( *end ) break;

    /***** check for overflow */
    if( errno==ERANGE ) {
      fprintf(stderr, 
	      "%s: parameter `%s' of option `%s' to large to represent\n",
	      Program, argv[i+used+1], argv[i]);
      exit(EXIT_FAILURE);
    }

  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be an "
	    "integer value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/

int
getFloatOpt(int argc, char **argv, int i, float *value, int force)
{
  char *end;
  double v;

  if( ++i>=argc ) goto nothingFound;

  errno = 0;
  v = strtod(argv[i], &end);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace((int) *end) ) end+=1;
  if( *end ) goto nothingFound;

  /***** check for overflow */
  checkFloatConversion(v, argv[i-1], argv[i]);

  *value = (float)v;

  return i;

nothingFound:
  if( !force ) return i-1;

  fprintf(stderr,
	  "%s: missing or malformed float value after option `%s'\n",
	  Program, argv[i-1]);
  exit(EXIT_FAILURE);
 
}
/**********************************************************************/

int
getFloatOpts(int argc, char **argv, int i, 
	   float **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;
  double v;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values.
  *****/
  alloced = cmin + 4;
  *values = (float*)calloc((size_t)alloced, sizeof(float));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = (float *) realloc(*values, alloced*sizeof(float));
      if( !*values ) goto outMem;
    }

    errno = 0;
    v = strtod(argv[used+i+1], &end);

    /***** check for conversion error */
    if( end==argv[used+i+1] ) break;

    /***** check for surplus non-whitespace */
    while( isspace((int) *end) ) end+=1;
    if( *end ) break;

    /***** check for overflow */
    checkFloatConversion(v, argv[i], argv[i+used+1]);
    
    (*values)[used] = (float)v;
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be a "
	    "floating-point value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/

int
getDoubleOpt(int argc, char **argv, int i, double *value, int force)
{
  char *end;

  if( ++i>=argc ) goto nothingFound;

  errno = 0;
  *value = strtod(argv[i], &end);

  /***** check for conversion error */
  if( end==argv[i] ) goto nothingFound;

  /***** check for surplus non-whitespace */
  while( isspace((int) *end) ) end+=1;
  if( *end ) goto nothingFound;

  /***** check for overflow */
  if( errno==ERANGE ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of option `%s' to %s to represent\n",
	    Program, argv[i], argv[i-1],
	    (*value==0.0 ? "small" : "large"));
    exit(EXIT_FAILURE);
  }

  return i;

nothingFound:
  if( !force ) return i-1;

  fprintf(stderr,
	  "%s: missing or malformed value after option `%s'\n",
	  Program, argv[i-1]);
  exit(EXIT_FAILURE);
 
}
/**********************************************************************/

int
getDoubleOpts(int argc, char **argv, int i, 
	   double **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  /***** 
    alloc a bit more than cmin values.
  *****/
  alloced = cmin + 4;
  *values = (double*)calloc((size_t)alloced, sizeof(double));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory while parsing option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = (double *) realloc(*values, alloced*sizeof(double));
      if( !*values ) goto outMem;
    }

    errno = 0;
    (*values)[used] = strtod(argv[used+i+1], &end);

    /***** check for conversion error */
    if( end==argv[used+i+1] ) break;

    /***** check for surplus non-whitespace */
    while( isspace((int) *end) ) end+=1;
    if( *end ) break;

    /***** check for overflow */
    if( errno==ERANGE ) {
      fprintf(stderr, 
	      "%s: parameter `%s' of option `%s' to %s to represent\n",
	      Program, argv[i+used+1], argv[i],
	      ((*values)[used]==0.0 ? "small" : "large"));
      exit(EXIT_FAILURE);
    }

  }
    
  if( used<cmin ) {
    fprintf(stderr, 
	    "%s: parameter `%s' of `%s' should be a "
	    "double value\n",
	    Program, argv[i+used+1], argv[i]);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/

/**
  force will be set if we need at least one argument for the option.
*****/
int
getStringOpt(int argc, char **argv, int i, char **value, int force)
{
  i += 1;
  if( i>=argc ) {
    if( force ) {
      fprintf(stderr, "%s: missing string after option `%s'\n",
	      Program, argv[i-1]);
      exit(EXIT_FAILURE);
    } 
    return i-1;
  }
  
  if( !force && argv[i][0] == '-' ) return i-1;
  *value = argv[i];
  return i;
}
/**********************************************************************/

int
getStringOpts(int argc, char **argv, int i, 
	   char*  **values,
	   int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;

  if( i+cmin >= argc ) {
    fprintf(stderr, 
	    "%s: option `%s' wants at least %d parameters\n",
	    Program, argv[i], cmin);
    exit(EXIT_FAILURE);
  }

  alloced = cmin + 4;
    
  *values = (char**)calloc((size_t)alloced, sizeof(char*));
  if( ! *values ) {
outMem:
    fprintf(stderr, 
	    "%s: out of memory during parsing of option `%s'\n",
	    Program, argv[i]);
    exit(EXIT_FAILURE);
  }

  for(used=0; (cmax==-1 || used<cmax) && used+i+1<argc; used++) {
    if( used==alloced ) {
      alloced += 8;
      *values = (char **)realloc(*values, alloced*sizeof(char*));
      if( !*values ) goto outMem;
    }

    if( used>=cmin && argv[used+i+1][0]=='-' ) break;
    (*values)[used] = argv[used+i+1];
  }
    
  if( used<cmin ) {
    fprintf(stderr, 
    "%s: less than %d parameters for option `%s', only %d found\n",
	    Program, cmin, argv[i], used);
    exit(EXIT_FAILURE);
  }

  return i+used;
}
/**********************************************************************/

void
checkIntLower(char *opt, int *values, int count, int max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%d\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
checkIntHigher(char *opt, int *values, int count, int min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%d\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
checkLongLower(char *opt, long *values, int count, long max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%ld\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
checkLongHigher(char *opt, long *values, int count, long min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%ld\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
checkFloatLower(char *opt, float *values, int count, float max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%f\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
checkFloatHigher(char *opt, float *values, int count, float min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%f\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
checkDoubleLower(char *opt, double *values, int count, double max)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]<=max ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' greater than max=%f\n",
	    Program, i+1, opt, max);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

void
checkDoubleHigher(char *opt, double *values, int count, double min)
{
  int i;

  for(i=0; i<count; i++) {
    if( values[i]>=min ) continue;
    fprintf(stderr, 
	    "%s: parameter %d of option `%s' smaller than min=%f\n",
	    Program, i+1, opt, min);
    exit(EXIT_FAILURE);
  }
}
/**********************************************************************/

static char *
catArgv(int argc, char **argv)
{
  int i;
  size_t l;
  char *s, *t;

  for(i=0, l=0; i<argc; i++) l += (1+strlen(argv[i]));
  s = (char *)malloc(l);
  if( !s ) {
    fprintf(stderr, "%s: out of memory\n", Program);
    exit(EXIT_FAILURE);
  }
  strcpy(s, argv[0]);
  t = s;
  for(i=1; i<argc; i++) {
    t = t+strlen(t);
    *t++ = ' ';
    strcpy(t, argv[i]);
  }
  return s;
}
/**********************************************************************/

void
usage(void)
{
  fprintf(stderr, "usage: %s%s", Program, "\
 [-help] [-V] [-random] [-complete] [-onestep] [-multistep] [-negascout] [-fixed] [-relative] [-record] [-position] [-nobook] [-noresign] [-norecord] [-log logfile] [-gamefile gamefile] [-values valuefile] [-config configfile] [-compname computername] [-book bookfile] [-guiveup resign] [-d d] [-r randomvariance] [-hs hashsize] [-hk hashkilobytes] [-mindepth epdmindepth] [-draw drawvalue] [-v verbose]\n\
    IETF protocol 2 compliant chess engine\n\
       -help: show usage information\n\
          -V: show program version\n\
     -random: play random moves\n\
   -complete: play full negamax\n\
    -onestep: play with depth of one\n\
  -multistep: play with fixed depth alpha-beta cutoff algorithm\n\
  -negascout: play with iterative deepening negascout algorithm (default)\n\
      -fixed: evaluate board by fixed piece values\n\
   -relative: evaluate board by relative proportion to opponent\n\
     -record: record game\n\
   -position: evaluate board by piece values relative to position\n\
     -nobook: do not use opening book\n\
   -noresign: never resign\n\
   -norecord: do not record the game\n\
        -log: file where to write all spurious output messages\n\
              1 char* value\n\
   -gamefile: file where to record the games\n\
              1 char* value\n\
     -values: file specifying pieces values\n\
              1 char* value\n\
     -config: configuration file - default is sp.rc, or sp.ini \n\
              1 char* value\n\
   -compname: name to report for the engine \n\
              1 char* value\n\
       -book: opening book file\n\
              1 char* value\n\
    -guiveup: Pawn values deficit at which to resign (default is 6.5, will be ignored if combined with -relative) \n\
              1 float value\n\
          -d: maximum depth of search\n\
              1 int value between 0 and 100\n\
          -r: randomness introduced into the evaluation algorithm as a percentage of a pawn's value\n\
              1 int value\n\
         -hs: number of entries in hash table (will be deprecated)\n\
              1 int value between 0 and oo\n\
         -hk: hash table size in kilobytes\n\
              1 int value between 0 and oo\n\
   -mindepth: minimum depth at which an epd can be considered solved\n\
              1 int value between 0 and oo\n\
       -draw: value, in hundredth of a pawn, of a draw\n\
              1 int value\n\
          -v: verbosity level\n\
              1 int value between 0 and oo\n\
version: 0.6.1\n\
");
  exit(EXIT_FAILURE);
}
/**********************************************************************/
Cmdline *
parseCmdline(int argc, char **argv)
{
  int i;

  Program = argv[0];
  cmd.tool = catArgv(argc, argv);
  for(i=1, cmd.argc=1; i<argc; i++) {
    if( 0==strcmp("-help", argv[i]) ) {
      cmd.show_helpP = 1;
      continue;
    }

    if( 0==strcmp("-V", argv[i]) ) {
      cmd.show_versionP = 1;
      continue;
    }

    if( 0==strcmp("-random", argv[i]) ) {
      cmd.randomP = 1;
      continue;
    }

    if( 0==strcmp("-complete", argv[i]) ) {
      cmd.completeP = 1;
      continue;
    }

    if( 0==strcmp("-onestep", argv[i]) ) {
      cmd.onestepP = 1;
      continue;
    }

    if( 0==strcmp("-multistep", argv[i]) ) {
      cmd.multistepP = 1;
      continue;
    }

    if( 0==strcmp("-negascout", argv[i]) ) {
      cmd.negascoutP = 1;
      continue;
    }

    if( 0==strcmp("-fixed", argv[i]) ) {
      cmd.fixedevalP = 1;
      continue;
    }

    if( 0==strcmp("-relative", argv[i]) ) {
      cmd.relativeevalP = 1;
      continue;
    }

    if( 0==strcmp("-record", argv[i]) ) {
      cmd.recordP = 1;
      continue;
    }

    if( 0==strcmp("-position", argv[i]) ) {
      cmd.positionevalP = 1;
      continue;
    }

    if( 0==strcmp("-nobook", argv[i]) ) {
      cmd.nobookP = 1;
      continue;
    }

    if( 0==strcmp("-noresign", argv[i]) ) {
      cmd.noresignP = 1;
      continue;
    }

    if( 0==strcmp("-norecord", argv[i]) ) {
      cmd.norecordP = 1;
      continue;
    }

    if( 0==strcmp("-log", argv[i]) ) {
      int keep = i;
      cmd.logfileP = 1;
      i = getStringOpt(argc, argv, i, &cmd.logfile, 1);
      cmd.logfileC = i-keep;
      continue;
    }

    if( 0==strcmp("-gamefile", argv[i]) ) {
      int keep = i;
      cmd.gamefileP = 1;
      i = getStringOpt(argc, argv, i, &cmd.gamefile, 1);
      cmd.gamefileC = i-keep;
      continue;
    }

    if( 0==strcmp("-values", argv[i]) ) {
      int keep = i;
      cmd.valuefileP = 1;
      i = getStringOpt(argc, argv, i, &cmd.valuefile, 1);
      cmd.valuefileC = i-keep;
      continue;
    }

    if( 0==strcmp("-config", argv[i]) ) {
      int keep = i;
      cmd.configfileP = 1;
      i = getStringOpt(argc, argv, i, &cmd.configfile, 1);
      cmd.configfileC = i-keep;
      continue;
    }

    if( 0==strcmp("-compname", argv[i]) ) {
      int keep = i;
      cmd.computernameP = 1;
      i = getStringOpt(argc, argv, i, &cmd.computername, 1);
      cmd.computernameC = i-keep;
      continue;
    }

    if( 0==strcmp("-book", argv[i]) ) {
      int keep = i;
      cmd.bookfileP = 1;
      i = getStringOpt(argc, argv, i, &cmd.bookfile, 1);
      cmd.bookfileC = i-keep;
      continue;
    }

    if( 0==strcmp("-guiveup", argv[i]) ) {
      int keep = i;
      cmd.resignP = 1;
      i = getFloatOpt(argc, argv, i, &cmd.resign, 1);
      cmd.resignC = i-keep;
      continue;
    }

    if( 0==strcmp("-d", argv[i]) ) {
      int keep = i;
      cmd.dP = 1;
      i = getIntOpt(argc, argv, i, &cmd.d, 1);
      cmd.dC = i-keep;
      checkIntLower("-d", &cmd.d, cmd.dC, 100);
      checkIntHigher("-d", &cmd.d, cmd.dC, 0);
      continue;
    }

    if( 0==strcmp("-r", argv[i]) ) {
      int keep = i;
      cmd.randomvarianceP = 1;
      i = getIntOpt(argc, argv, i, &cmd.randomvariance, 1);
      cmd.randomvarianceC = i-keep;
      continue;
    }

    if( 0==strcmp("-hs", argv[i]) ) {
      int keep = i;
      cmd.hashsizeP = 1;
      i = getIntOpt(argc, argv, i, &cmd.hashsize, 1);
      cmd.hashsizeC = i-keep;
      checkIntHigher("-hs", &cmd.hashsize, cmd.hashsizeC, 0);
      continue;
    }

    if( 0==strcmp("-hk", argv[i]) ) {
      int keep = i;
      cmd.hashkilobytesP = 1;
      i = getIntOpt(argc, argv, i, &cmd.hashkilobytes, 1);
      cmd.hashkilobytesC = i-keep;
      checkIntHigher("-hk", &cmd.hashkilobytes, cmd.hashkilobytesC, 0);
      continue;
    }

    if( 0==strcmp("-mindepth", argv[i]) ) {
      int keep = i;
      cmd.epdmindepthP = 1;
      i = getIntOpt(argc, argv, i, &cmd.epdmindepth, 1);
      cmd.epdmindepthC = i-keep;
      checkIntHigher("-mindepth", &cmd.epdmindepth, cmd.epdmindepthC, 0);
      continue;
    }

    if( 0==strcmp("-draw", argv[i]) ) {
      int keep = i;
      cmd.drawvalueP = 1;
      i = getIntOpt(argc, argv, i, &cmd.drawvalue, 1);
      cmd.drawvalueC = i-keep;
      continue;
    }

    if( 0==strcmp("-v", argv[i]) ) {
      int keep = i;
      cmd.verboseP = 1;
      i = getIntOpt(argc, argv, i, &cmd.verbose, 1);
      cmd.verboseC = i-keep;
      checkIntHigher("-v", &cmd.verbose, cmd.verboseC, 0);
      continue;
    }

    if( argv[i][0]=='-' ) {
      fprintf(stderr, "\n%s: unknown option `%s'\n\n",
              Program, argv[i]);
      usage();
    }
    argv[cmd.argc++] = argv[i];
  }/* for i */


  /*@-mustfree*/
  cmd.argv = argv+1;
  /*@=mustfree*/
  cmd.argc -= 1;

  if( cmd.argc>0 ) {
    fprintf(stderr, "%s: There are %d arguments not associated with any option\n",
            Program, cmd.argc);
    exit(EXIT_FAILURE);
  }
  /*@-compmempass*/  return &cmd;
}

